//#RequireContext CTmMode

#Extends "Modes/TrackMania/Base/RoundsBase2TMAllMaker.Script.txt"

#Const CompatibleMapTypes	"Race"
#Const Version							"2018-03-08"
#Const ScriptName						"Modes/TrackMania/Rounds/Rounds.Script.txt"

// ---------------------------------- //
// Libraries
// ---------------------------------- //
#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "Libs/Nadeo/Semver.Script.txt" as Semver

// ---------------------------------- //
// Settings
// ---------------------------------- //
#Setting S_PointsLimit			50
#Setting S_TurboFinishTime		True as _("Reset Timeout on Finish :")
#Setting S_RoundsPerMap		-1 as _("Number of rounds per map :") ///< Number of round to play on one map before going to the next one
#Setting S_MapsPerMatch		-1 as _("Number of maps per match :") ///< Number of maps to play before finishing the match
#Setting S_UseTieBreak			True	as _("Use tie-break :")	///< Continue to play the map until the tie is broken
#Setting S_WarmUpNb				0	as _("Number of warm up :")
#Setting S_WarmUpDuration	0	as _("Duration of one warm up :")
#Setting S_MaximumStuntRemoval 0.33 as _("Maximum Stunt Removal :")

#Setting S_ScriptEnvironment "production"/*/"development"*/

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_BotsNb 0
#Const C_HudModulePath "Nadeo/TrackMania/Rounds/Hud.Module.Gbx" ///< Path to the hud module
#Const C_ManiaAppUrl "file://Media/ManiaApps/Nadeo/TrackMania/Rounds/Rounds.Script.txt"
#Const C_BaseStuntWorth 30
#Const C_SimpleStuntWorth 5
#Const C_WreckStuntWorth 5
#Const C_RotationalStuntBonus 15
#Const C_CarIndex [0 => "trackmania:stadiumcar",1 => "trackmania:canyoncar",2 => "trackmania:valleycar",3 => "trackmania:lagooncar",4 => "trackmania:desertcar",5 => "trackmania:rallycar",6 => "trackmania:snowcar",7 => "trackmania:coastcar",8 => "trackmania:islandcar",9 => "trackmania:baycar", 10 => "trackmania:trafficcar", 11 => "tmall:canyoncarflippy"]

#Const Description _("""$fffA moddified version of Nadeo's rounds script which allows mappers to add (usually) fun effects to their maps!!!""")

#Struct NetStuntData{
    Text StuntName;
    Integer StuntScore;
    Integer StuntTime;
}

declare Integer[] UsedCars;
declare Integer[] MapCars;
declare Ident[Text] CarModels;
declare Vec3[Integer] RandFinList;
declare Vec3 PreviousFirstFin;
declare CUILayer FinishMarker;

// ---------------------------------- //
// Extends
// ---------------------------------- //
***Match_LogVersion***
***
MB_LogVersion(ScriptName, Version);
***

***Match_Settings***
***
MB_Settings_UseDefaultHud = False;
***

***Match_Rules***
***
ModeInfo::SetName("KEKLRounds");
ModeInfo::SetType(ModeInfo::C_Type_FreeForAll);
ModeInfo::SetRules(Description);
ModeInfo::SetStatusMessage("");
***

***Match_LoadHud***
***
ClientManiaAppUrl = C_ManiaAppUrl;
Hud_Load(C_HudModulePath);
MB_SortScores(CTmMode::ETmScoreSortOrder::TotalPoints);
***

***TMAll_ItemList***
***
declare PlayerModels_Server::K_Options NewOptions;
NewOptions.LoadingMode = PlayerModels_Server::C_LoadingMode_LoadEverything;
PlayerModels_Server::Load(This, NewOptions);
***

***Match_InitServer***
***
declare Text RoundCar for Teams[0];
declare PrevPointsLimit = S_PointsLimit - 1;
declare PrevRoundsPerMap = S_RoundsPerMap - 1;
declare PrevMapsPerMatch = S_MapsPerMatch - 1;
***

***Match_StartServer***
***
InitKEKUiLayer();
SetupGlobalFinishMarker();
WarmUp::SetAvailability(True);
ChannelProgression::Enable(S_IsChannelServer);
Scores::SaveInScore(Scores::C_Points_Match);
***

***Match_InitMap***
***
RoundCar = "Default";
UpdateScoresTableFooter(S_PointsLimit, S_RoundsPerMap, S_MapsPerMatch);
***

***Match_StartMap***
***
//Init KEKL Effects
declare metadata Boolean RandEvents for Map;
declare metadata Boolean SizeChanges for Map;
declare metadata Integer EffectVersion for Map;

if (EffectVersion == 0){
EnableScaleCar = RandEvents;
EnableBonusEvents = RandEvents;
EnableCheckpointBonus = RandEvents;
}
else {
EnableScaleCar = SizeChanges;
EnableBonusEvents = RandEvents;
EnableCheckpointBonus = (SizeChanges || RandEvents);
}
MapCars = GetMapCars();
UsedCars.clear();
foreach (Player in AllPlayers) {
SetPlayerSettings(Player);
}

AddAndRemoveMarker(True);


// ---------------------------------- //
// Initialize map
Users_SetNbFakeUsers(C_BotsNb, 0);

// ---------------------------------- //
// Warm up
declare WarmUpDuration = S_WarmUpDuration * 1000;
MB_WarmUp(S_WarmUpNb, WarmUpDuration);

// ---------------------------------- //
// Restore score from previous map
foreach (Score in Scores) {
declare Real[] Rounds_RoundsPerformance for Score;
Rounds_RoundsPerformance = [];
}
***

***Match_InitRound***
***
declare metadata Boolean RandCars for Map;
declare metadata Boolean RandomFinishes for Map;
RoundCar = "Default";
if (RandCars) {
SetRoundCar();
}
RandFinList.clear();
if (RandomFinishes){
    RandFinList = GetRandomFinArray();
}

foreach (Player in AllPlayers) {
SetupFinishMarkerForPlayer(Player);
declare netwrite Integer ScriptedStuntPoints for Player.Score;
declare Integer CheckpointStuntSnapshot for Player.Score;
ScriptedStuntPoints = 0;
CheckpointStuntSnapshot = 0;
SetPlayerPenalty(Player, 0, False);
SetPlayerSettings(Player);
}
foreach(Score in Scores){
    declare Boolean EndedOnWrongFinish for Score;
    EndedOnWrongFinish = False;
}
***

***Match_StartRound***
***
declare metadata Boolean IncStuntPoints for Map;
declare metadata Integer EffectVersion for Map;
UpdateScoresTableFooter(S_PointsLimit, S_RoundsPerMap, S_MapsPerMatch);
/*      Will see how things play out without this.
if (IncStuntPoints && EffectVersion >= 2){
    CutOffTimeLimit = Now + (Map.TMObjective_AuthorTime + 33000);
}
*/
***

***Match_PlayLoop***
***
declare metadata Boolean UseCrashPenalty for Map;
declare metadata Boolean IncStuntPoints for Map;
declare metadata Boolean RandomFinishes for Map;
foreach (Player in AllPlayers) {
    declare Integer PenaltyTimeout for Player.User;
    if (PenaltyTimeout < Now && PenaltyTimeout != 0) {
        SetPlayerPenalty(Player, 0, True);
    }
SetPlayerSettings(Player);
}
if (UseCrashPenalty) {
foreach (UiEvent in UIManager.PendingEvents) {
switch (UiEvent.CustomEventType) {
    case "RaceEvent": {
        declare CTmPlayer UiEventPlayer = GetPlayer(UiEvent.CustomEventData[1]);
        switch (UiEvent.CustomEventData[0]) {
            case "Impact": {
                SetPlayerPenalty(UiEventPlayer, 2000, True);
            }
        }
    }
}
}
}
foreach (Event in PendingEvents) {
declare Processed = Events::Valid(Event);
if (!Processed) continue;
switch (Event.Type) {
case CTmModeEvent::EType::WayPoint: {
    declare Integer CheckpointStuntSnapshot for Event.Player.Score;
    declare netwrite Integer ScriptedStuntPoints for Event.Player.Score;
    declare Boolean CanSkipPenalty for Event.Player.User;
    CheckpointStuntSnapshot = ScriptedStuntPoints;
    if (CanSkipPenalty){
        SetPlayerPenalty(Event.Player, 0, False);
    }
    if (Event.IsEndRace) {
        declare Boolean EndedOnWrongFinish for Event.Player.Score;
        if (RandomFinishes && !DidFinishAtTarget(Event.Player.Position, RandFinList[Event.Player.CurrentNbLaps - 1])){
            EndedOnWrongFinish = True;
        }
        declare Better = Scores::SetPlayerBestRaceIfBetter(Event.Player.Score, Event.Player.CurRace, CTmResult::ETmRaceResultCriteria::Time);
        Scores::SetPlayerPrevRace(Event.Player.Score, Event.Player.CurRace);
        ComputeLatestRaceScores(False);
        MB_SortScores(CTmMode::ETmScoreSortOrder::TotalPoints);
        TM::EndRace(Event.Player);
        if (!EndedOnWrongFinish){
            if (S_TurboFinishTime) {
                CutOffTimeLimit = GetFinishTimeout();
            }
            else if (CutOffTimeLimit <= 0) {
                CutOffTimeLimit = GetFinishTimeout();
            }
        }
    }
    if (Event.IsEndLap) {
        if (RandomFinishes && !Event.IsEndRace && !DidFinishAtTarget(Event.Player.Position, RandFinList[Event.Player.CurrentNbLaps - 1])){
            SetPlayerPenalty(Event.Player, 3000, False);
        }
        SetupFinishMarkerForPlayer(Event.Player);
        declare Better = Scores::SetPlayerBestLapIfBetter(Event.Player.Score, Event.Player.CurLap, CTmResult::ETmRaceResultCriteria::Time);
    }
}
case CTmModeEvent::EType::Respawn: {
    declare Boolean CanSkipPenalty for Event.Player.User;
    if (CanSkipPenalty){
        SetPlayerPenalty(Event.Player, 0, False);
    }
}
case CTmModeEvent::EType::GiveUp: {
    TM::WaitRace(Event.Player);
}
case CTmModeEvent::EType::Stunt: {
    if (IncStuntPoints){
        RegisterStunt(Event);
    }
}
case CTmModeEvent::EType::OnPlayerAdded: {
    if (Event.Player != Null) {
        SetPlayerSettings(Event.Player);
        SetupFinishMarkerForPlayer(Event.Player);
    }
}
}
}

// ---------------------------------- //
// Server info change
if (
PrevPointsLimit != S_PointsLimit ||
PrevRoundsPerMap != S_RoundsPerMap ||
PrevMapsPerMatch != S_MapsPerMatch
) {
PrevPointsLimit = S_PointsLimit;
PrevRoundsPerMap = S_RoundsPerMap;
PrevMapsPerMatch = S_MapsPerMatch;

UpdateScoresTableFooter(S_PointsLimit, S_RoundsPerMap, S_MapsPerMatch);
}
***

***Match_EndRound***
***
AddAndRemoveMarker(True);
TM::WaitRaceAll();
CutOffTimeLimit = -1;

if (Semver::Compare(XmlRpc::GetApiVersion(), ">=", "2.1.1")) {
Scores::XmlRpc_SendScores(Scores::C_Section_PreEndRound, "");
}

if (ForceEndRound || SkipPauseRound) {
// Cancel points
foreach (Score in Scores) {
    Scores::SetPlayerRoundPoints(Score, 0);
}
// Do not launch the forced end round sequence after a pause
if (!SkipPauseRound) {
    ForcedEndRoundSequence();
}
} else {
// Compute round performance
declare ReferenceTime = Map.MapInfo.TMObjective_AuthorTime;
declare BestRaceTime = ReferenceTime;
foreach (Score in Scores) {
    declare RaceTime = Scores::GetPlayerPrevRaceTime(Score);
    if (RaceTime > 0 && RaceTime < BestRaceTime) {
        BestRaceTime = RaceTime;
    }
}
if (BestRaceTime > 0 && BestRaceTime < ReferenceTime) ReferenceTime = BestRaceTime;

foreach (Score in Scores) {
    declare RoundPerformance = 0.;
    declare PrevRaceTime = Scores::GetPlayerPrevRaceTime(Score);
    
    if (
        PrevRaceTime > 0 &&
        ReferenceTime > 0 &&
        PrevRaceTime < Map.MapInfo.TMObjective_BronzeTime &&
        ReferenceTime < Map.MapInfo.TMObjective_BronzeTime
        ) {
            declare A = (Map.MapInfo.TMObjective_BronzeTime - PrevRaceTime) * 1.;
            declare B = Map.MapInfo.TMObjective_BronzeTime - ReferenceTime;
            RoundPerformance = ((A / B) * 0.9) + 0.1;
        }
        
        declare Real[] Rounds_RoundsPerformance for Score;
        Rounds_RoundsPerformance.add(RoundPerformance);
        
        Log::Log("""[Rounds] RoundPerformance > {{{Score.User.Login}}} > | PrevRaceTime : {{{PrevRaceTime}}} | BronzeTime : {{{Map.MapInfo.TMObjective_BronzeTime}}} | AuthorTime : {{{Map.MapInfo.TMObjective_AuthorTime}}} | BestRaceTime : {{{BestRaceTime}}} | ReferenceTime : {{{ReferenceTime}}} | RoundPerformance: {{{RoundPerformance}}}""");
    }
    
    // Get the last round points
    ComputeLatestRaceScores(True);
    MB_SortScores(CTmMode::ETmScoreSortOrder::TotalPoints);
    UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
    UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
    MB_Sleep(3000);
    // Add them to the total scores
    ComputeScores();
    MB_SortScores(CTmMode::ETmScoreSortOrder::TotalPoints);
    MB_Sleep(3000);
    UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
    UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
    
    if (MapIsOver()) MB_StopMap();
}
***

***Match_EndMap***
***
if (MatchIsOver()) MB_StopMatch();

if (!MB_MapIsRunning() && MB_MatchIsRunning()) MB_SkipPodiumSequence();

MB_SortScores(CTmMode::ETmScoreSortOrder::TotalPoints);
Scores::SetDefaultLadderSort(Scores::C_Sort_MapPoints);
Scores::SetPlayerWinner(Scores::GetBestPlayer(Scores::C_Sort_MatchPoints, Scores::Order_Descending()));
***

***Match_BeforeCloseLadder***
***
if (ChannelProgression::IsEnabled()) {
    declare RoundsCount = MB_GetRoundCount();
    foreach (Score in Scores) {
        declare Real[] Rounds_RoundsPerformance for Score;
        declare RoundsPerformance = 0.;
        if (RoundsCount != 0) {
            foreach (RoundPerformance in Rounds_RoundsPerformance) {
                RoundsPerformance += RoundPerformance;
            }
            RoundsPerformance /= RoundsCount;
        }
        
        Log::Log("""[Rounds] RoundsPerformance > {{{Score.User.Login}}} > Rounds_RoundsPerformance : {{{Rounds_RoundsPerformance}}} | RoundsCount : {{{RoundsCount}}} | RoundsPerformance: {{{RoundsPerformance}}}""");
        
        ChannelProgression::SetPlayerPerformance(Score, RoundsPerformance);
    }
}
***

***TMAll_AfterAutoGameplay***
***
declare Text RoundCar for Teams[0];
log(RoundCar);
if (RoundCar == "Default" || RoundCar == ""){
    PlayerModels_Server::AssignModel(_Player);
}
else {
    PlayerModels_Server::AssignModel(_Player, RoundCar);
}
***

Void AddAndRemoveMarker(Boolean DoRemove){
    if (DoRemove){
        FinishMarker.IsVisible = False;
        UIManager.UIAll.UILayers.remove(FinishMarker);
    }
    else {
        FinishMarker.IsVisible = True;
        UIManager.UIAll.UILayers.add(FinishMarker);
    }
}

Void SetupGlobalFinishMarker(){
    FinishMarker = UIManager.UILayerCreate();
    FinishMarker.Type = CUILayer::EUILayerType::Markers;
    FinishMarker.ManialinkPage = """
    <?xml version="1.0" encoding="utf-8" standalone="yes" ?>
    <manialink version="3">
        <frame id="Frame_FinishMarker">
            <quad pos="0 0" z-index="0" size="10 10" bgcolor="FFFA" halign="center" valign="center" style="Icons128x32_1" substyle="RT_Rounds"/>
            <quad pos="0 0" z-index="0" size="20 20" bgcolor="FFFA" halign="center" valign="center" style="Bgs1InRace" substyle="Glow"/>
        </frame>
        <script><!--
        main(){
            declare metadata Boolean RandomFinishes for Map;
            declare CMlFrame MarkerFrame = (Page.GetFirstChild("Frame_FinishMarker") as CMlFrame);
            while(True){
                yield();
                if (RandomFinishes){
                    MarkerFrame.Show();
                }
                else {
                    MarkerFrame.Hide();
                }
            }
        }
        --></script>
    </manialink>
    """;
}

Void SetupFinishMarkerForPlayer(CTmPlayer _Player){
    declare metadata Boolean RandomFinishes for Map;
    if (RandomFinishes){
        UIManager.UIAll.LabelsVisibility = CUIConfig::EHudVisibility::MarkersOnly;
        AddAndRemoveMarker(False);
        declare CUIConfig PlayerUI = UIManager.GetUI(_Player);
        declare Integer FinIndex;
        if (MapIsLapRace){
            if (_Player.CurrentNbLaps < MapNbLaps){
                if (_Player.CurrentNbLaps <= 0){
                    FinIndex = 0;
                }
                else {
                    FinIndex = _Player.CurrentNbLaps;
                }
            }
        }
        else {
            FinIndex = 0;
        }
        declare Vec3 FinishPosition = RandFinList[FinIndex];
        PlayerUI.MarkersXML = """<marker pos="{{{FinishPosition.X}}} {{{FinishPosition.Y}}} {{{FinishPosition.Z}}}" manialinkframeid="Frame_FinishMarker"/>""";
    }
    else {
        UIManager.UIAll.LabelsVisibility = CUIConfig::EHudVisibility::Default;
        AddAndRemoveMarker(True);
    }
    
}

Boolean DidFinishAtTarget(Vec3 _PlayerPos, Vec3 _TargetFin){
    declare Vec3 ClosestFin;
    declare Real PreviousFinDist;
    foreach(Fin in MapFinishLinePos){
        if (ClosestFin == <0.0, 0.0, 0.0> || PreviousFinDist > ML::Distance(_PlayerPos, Fin)){
            ClosestFin = Fin;
            PreviousFinDist = ML::Distance(_PlayerPos, Fin);
        }
    }
    if (ClosestFin == _TargetFin){
        return True;
    }
    return False;
}

Vec3[Integer] GetRandomFinArray(){
    declare Vec3[Integer] FinArray;
    declare Vec3 CurRandFin;
    while(FinArray.count != MapNbLaps){
        if (MapFinishLinePos.count > 1){
            CurRandFin = MapFinishLinePos[ML::Rand(0, MapFinishLinePos.count - 1)];
            if (FinArray.count == 0){
                if (PreviousFirstFin == <0.0, 0.0, 0.0> || PreviousFirstFin != CurRandFin){
                    FinArray[FinArray.count] = CurRandFin;
                }
            }
            else {
                if (CurRandFin != FinArray[FinArray.count - 1]){
                    FinArray[FinArray.count] = CurRandFin;
                }
            }
        }
        else {
            FinArray[FinArray.count] = MapFinishLinePos[0];
        }
    }
    PreviousFirstFin = FinArray[0];
    return FinArray;
}

Void RegisterStunt(CTmModeEvent _Event){
    declare Integer CheckpointStuntSnapshot for _Event.Player.Score;
    declare netwrite Integer ScriptedStuntPoints for _Event.Player.Score;
    declare netwrite NetStuntData NetStuntEvent for _Event.Player.Score;
    declare Text StuntName = TL::Replace(_Event.StuntFigure ^ "", "::EStuntFigure::", "");
    declare Integer CurStuntPoints;
    declare Integer StuntType = 0;
    if (StuntName == "RespawnPenalty"){
        StuntName = "SegmentRespawn";
        StuntType = 1;
        CurStuntPoints = -1 * (ScriptedStuntPoints - CheckpointStuntSnapshot);
    }   
    else{
        if (StuntName == "StraightJump"){
            StuntType = 2;
            CurStuntPoints = C_SimpleStuntWorth;
        }
        else if (TL::EndsWith("Wreck", StuntName)){
            StuntType = 3;
            CurStuntPoints = C_WreckStuntWorth;
        }
        else {
            StuntType = 0;
            CurStuntPoints = C_BaseStuntWorth;
        }
        // Don't allow combos for 
        if (StuntType != 2){
            CurStuntPoints += (C_RotationalStuntBonus * (_Event.Angle / 180));
            CurStuntPoints = (CurStuntPoints * (_Event.Combo + 1));
        }
    }
    NetStuntEvent.StuntScore = CurStuntPoints;
    // ^ " " ^ _Event.Angle ^ " x" ^ _Event.Combo ^ "!!!"
    if (_Event.Angle > 0){
        StuntName ^= " " ^ _Event.Angle;
    }
    if (_Event.Combo > 0){
        StuntName ^= " x" ^ (_Event.Combo + 1);
    }
    if (StuntType == 0){
        StuntName ^= "!!!";
    }
    NetStuntEvent.StuntName = StuntName;
    NetStuntEvent.StuntTime = Now;
    ScriptedStuntPoints += CurStuntPoints;
    if (ScriptedStuntPoints <= 0){
        ScriptedStuntPoints = 0;
    }
}

Void TogglePlayerInput(CTmPlayer _Player, Boolean _HasControl, Boolean _CanSteer){
    if (!_HasControl){
        _Player.CoopMode = CTmPlayer::ETmRacePlayerCoopMode::Symbiosys;
        _Player.ControllerCount = 1;
        if (_CanSteer){
            _Player.ControllerId0 = 1;
        }
        else {
            _Player.ControllerId0 = 2;
        }
    }
    else {
        _Player.ControllerCount = 0;
        _Player.ControllerId0 = -1;
        _Player.CoopMode = CTmPlayer::ETmRacePlayerCoopMode::None;
    }
}

Void SetPlayerSettings(CTmPlayer _Player){
    declare Integer PenaltyTimeout for _Player.User;
    if (PenaltyTimeout < Now || PenaltyTimeout == 0) {
        TogglePlayerInput(_Player, True, True);
    }
    else {
        TogglePlayerInput(_Player, False, False);
    }
}

Void SetPlayerPenalty(CTmPlayer _Player, Integer _PenaltyTime, Boolean _CanSkipPen){
    declare netwrite Integer[Text] NetPentalty for Teams[0];
    declare Integer PenaltyTimeout for _Player.User;
    declare Boolean CanSkipPenalty for _Player.User;
    CanSkipPenalty = _CanSkipPen;
    if (_PenaltyTime <= 0) {
        PenaltyTimeout = 0;
    }
    else {
        PenaltyTimeout = Now + _PenaltyTime;
    }
    NetPentalty[_Player.User.Login] = PenaltyTimeout;
}
Integer[] GetMapCars(){
    declare metadata Integer EffectVersion for Map;
    declare metadata Boolean[Integer] EnabledCars for Map;
    declare Integer[] CarList;
    if (EffectVersion != 0){
        for (i, 0, 11){
            if (EnabledCars[i]){
                CarList.add(i);
            }
        }
        return CarList;
    }
    return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
}
Void SetRoundCar(){
    declare Text RoundCar for Teams[0];
    declare Integer CarIndex;
    declare Boolean CarFound;
    if (UsedCars.count == MapCars.count) {
        UsedCars.clear();
    }
    while (!CarFound) {
        yield;
        CarIndex = MapCars[ML::Rand(0, MapCars.count - 1)];
        if (!UsedCars.exists(CarIndex)) {
            CarFound = True;
        }
    }
    UsedCars.add(CarIndex);
    RoundCar = C_CarIndex[CarIndex];
}

// ---------------------------------- //
// Functions
// ---------------------------------- //
// ---------------------------------- //
/** Update the scores table footer text
*
*	@param	_PointsLimit							The points limit
*	@param	_RoundsPerMap							The number of round per map
*	@param	_MapsPerMatch							The number of maps per match
*/
Void UpdateScoresTableFooter(Integer _PointsLimit, Integer _RoundsPerMap, Integer _MapsPerMatch) {
    if (Hud != Null && Hud.ScoresTable != Null) {
        declare Text[] Parts;
        declare metadata Integer RoundLimit for Map;
        declare Message = "";
        if (_PointsLimit > 0) {
            if (Parts.count > 0) Message ^= " | ";
            Message ^= """%{{{Parts.count + 1}}}{{{_PointsLimit}}}""";
            //L16N [Rounds] Number of points to reach to win the match.
            Parts.add(_("Points limit : "));
        }
        
        if (_RoundsPerMap > 0) {
            if (Parts.count > 0) Message ^= " | ";
            Message ^= """%{{{Parts.count + 1}}}{{{MB_GetRoundCount()}}}/{{{_RoundsPerMap}}}""";
            //L16N [Rounds] Number of rounds played during the map.
            Parts.add(_("Rounds : "));
        }
        else if (!(RoundLimit <= 0) && !(RoundLimit > 3)){
            if (Parts.count > 0) Message ^= " | ";
            Message ^= """%{{{Parts.count + 1}}}{{{MB_GetRoundCount()}}}/{{{RoundLimit}}}""";
            //L16N [Rounds] Number of rounds played during the map.
            Parts.add(_("Rounds : "));
        }
        
        if (_MapsPerMatch > 0) {
            if (Parts.count > 0) Message ^= " | ";
            Message ^= """%{{{Parts.count + 1}}}{{{MB_GetMapCount()}}}/{{{_MapsPerMatch}}}""";
            //L16N [Rounds] Number of maps played during the match.
            Parts.add(_("Maps : "));
        }
        
        switch (Parts.count) {
            case 0: Hud.ScoresTable.SetFooterText(Message);
            case 1: Hud.ScoresTable.SetFooterText(TL::Compose(Message, Parts[0]));
            case 2: Hud.ScoresTable.SetFooterText(TL::Compose(Message, Parts[0], Parts[1]));
            case 3: Hud.ScoresTable.SetFooterText(TL::Compose(Message, Parts[0], Parts[1], Parts[2]));
        }
        
    }
}

// ---------------------------------- //
/** Get the time left to the players to finish the round after the first player
*
*	@return 		The time left in ms
*/
Integer GetFinishTimeout() {
    declare FinishTimeout = 0;
    
    if (S_FinishTimeout >= 0) {
        FinishTimeout = S_FinishTimeout * 1000;
    } else {
        FinishTimeout = 5000;
        if (Map.TMObjective_IsLapRace && NbLaps > 0 && MapNbLaps > 0) {
            FinishTimeout += ((Map.TMObjective_AuthorTime / MapNbLaps) * NbLaps) / 6;
        } else {
            FinishTimeout += Map.TMObjective_AuthorTime / 6;
        }
    }
    
    if (S_UseAlternateRules) {
        if (Map.TMObjective_IsLapRace && NbLaps > 0 && MapNbLaps > 0) {
            return G_RoundStartTime + ((Map.TMObjective_AuthorTime / MapNbLaps) * NbLaps) + FinishTimeout;
        } else {
            return G_RoundStartTime + Map.TMObjective_AuthorTime + FinishTimeout;
        }
    } else {
        return Now + FinishTimeout;
    }
    
    // Default value from TMO, TMS (not used)
    return Now + 15000;
}

// ---------------------------------- //
/// Compute the latest race scores
Void ComputeLatestRaceScores(Boolean IsEndOfRound) {
    MB_SortScores(CTmMode::ETmScoreSortOrder::PrevRace_Time);
    
    // Only points for the first players
    if (S_UseAlternateRules) {
        declare Points = 1;
        
        foreach (Score in Scores) {
            if (Scores::GetPlayerPrevRaceTime(Score) > 0) {
                //Score.PrevRaceDeltaPoints = Points;
                Scores::SetPlayerRoundPoints(Score, Points);
                if (Points > 0) Points -= 1;
            } else {
                //Score.PrevRaceDeltaPoints = 0;
                Scores::SetPlayerRoundPoints(Score, 0);
            }
        }
    } 
    // Points distributed between all players
    else {		
        declare Text[Integer] PositionTerms = [0 => "st", 1 => "nd", 2 => "rd"];
        declare Text PositionTerm = "th";
        declare I = 0;

        declare metadata Boolean IncStuntPoints for Map;
        declare CScore StuntWinner;
        declare Integer StuntWinnerPoints;
        if (IncStuntPoints && IsEndOfRound){
            foreach (Score in Scores) { // loop once to get the stunt winner if stunts is enabled.
                declare netwrite Integer ScriptedStuntPoints for Score;
                if (Scores::GetPlayerPrevRaceTime(Score) > 0) {
                    if (StuntWinnerPoints == 0 || ScriptedStuntPoints > StuntWinnerPoints){
                        StuntWinner = Score;
                        StuntWinnerPoints = ScriptedStuntPoints;
                    }
                }
            }
            if (StuntWinner != Null && StuntWinnerPoints != 0){
                UIManager.UIAll.SendChat("$z$s$fff»» " ^ StuntWinner.User.Name ^ "$z$s got the most stunt points of " ^ StuntWinnerPoints ^ " this round!");
            }
            /* 
            if (StuntWinner != Null){
                UIManager.UIAll.SendChat("$Debug: " ^ StuntWinner.User.Name ^ "$z$s Got the highest score of " ^ StuntWinnerPoints);
            }*/
        }
        
        foreach (Score in Scores) {
            if (I < 3){
                PositionTerm = PositionTerms[I];
            }
            else {
                PositionTerm = "th";
            }
            
            declare Boolean EndedOnWrongFinish for Score;
            declare netwrite Integer ScriptedStuntPoints for Score;
            if (IsEndOfRound && EndedOnWrongFinish){
                UIManager.UIAll.SendChat("$z$s$fff»» " ^ Score.User.Name ^ "$z$s $F33finished at the wrong finish and got a point penalty!");
            }
            if (Scores::GetPlayerPrevRaceTime(Score) > 0) {
                declare Points = 0;
                declare PointsRepartition = Scores::GetPointsRepartition();
                declare Integer PointDifference;
                declare Integer WrongFinishScore;
                if (PointsRepartition.existskey(0) && PointsRepartition.existskey(1)){
                    PointDifference = PointsRepartition[0] - PointsRepartition[1];
                    WrongFinishScore = PointDifference * 2;
                }
                if (PointsRepartition.count > 0) {
                    if (PointsRepartition.existskey(I)) {
                        Points = PointsRepartition[I];
                    } else {
                        Points = PointsRepartition[PointsRepartition.count - 1];
                    }
                    if (EndedOnWrongFinish){
                        Points = WrongFinishScore;
                    }
                    if (IncStuntPoints){
                        declare Integer TempRoundScore = ML::NearestInteger(ML::NearestReal(Points) - (ML::NearestReal(Points) * S_MaximumStuntRemoval));
                        if (StuntWinnerPoints != 0 && IsEndOfRound && StuntWinnerPoints != 0){
                            declare Real PointFactor = (ML::NearestReal(ScriptedStuntPoints) / ML::NearestReal(StuntWinnerPoints));
                            declare Real StuntRoundScore = (ML::NearestReal(Points) * PointFactor) * S_MaximumStuntRemoval;
                            declare Integer FinalRoundScore = ML::NearestInteger(ML::NearestReal(Points) - (ML::NearestReal(Points) * S_MaximumStuntRemoval) + StuntRoundScore);
                            Points = FinalRoundScore;
                            UIManager.GetUI(Score.User).SendChat("$z$s$fff»$z$s You gained an additional " ^ ML::NearestInteger(StuntRoundScore) ^ " Points to your " ^ TempRoundScore ^ " points from placing " ^ (I + 1) ^  PositionTerm ^ " with " ^ ScriptedStuntPoints ^ " Stunt Points.");
                        }
                        else {
                            Points = TempRoundScore;
                        }
                        //UIManager.UIAll.SendChat("$Debug: " ^ Score.User.Name ^ "$z$s Got a score of " ^ ScriptedStuntPoints ^ ". New points: " ^ Points);
                    }
                }
                //Score.PrevRaceDeltaPoints = Points;
                Scores::SetPlayerRoundPoints(Score, Points);
                I += 1;
            } else {
                //Score.PrevRaceDeltaPoints = 0;
                Scores::SetPlayerRoundPoints(Score, 0);
            }
            if (IsEndOfRound){
                EndedOnWrongFinish = False;
            }
        }
    }
}

// ---------------------------------- //
/// Compute the map scores
Void ComputeScores() {
    Scores::EndRound();
}

// ---------------------------------- //
/** Check if the points limit was reached
*
*	@return														1 if the points limit is reached
*																		0 if there is a tie
*																		-1 if the points limit is not reached
*/
Integer PointsLimitReached() {
    declare MaxScore = -1;
    declare Tie = False;
    foreach (Score in Scores) {
        declare Points = Scores::GetPlayerMatchPoints(Score);
        if (Points > MaxScore) {
            MaxScore = Points;
            Tie = False;
        } else if (Points == MaxScore) {
            Tie = True;
        }
    }
    
    if (S_UseTieBreak && Tie) return 0; //< There is a tie and it is not allowed
    if (S_PointsLimit > 0 && MaxScore >= S_PointsLimit) return 1; //< There is a points limit and it is reached
    return -1; //< There is no points limit or the points limit is not reached
}

// ---------------------------------- //
/** Check if we should go to the next map
*
*	@return		True if it is the case, false otherwise
*/
Boolean MapIsOver() {
    declare metadata Integer RoundLimit for Map;
    if (S_RoundsPerMap > 0 && MB_GetRoundCount() >= S_RoundsPerMap) return True; //< There is a rounds limit and it is reached
    if (PointsLimitReached() == 1) return True; //< There is a points limit and it is reached
    if (!(RoundLimit <= 0) && !(RoundLimit > 3)){
        if (MB_GetRoundCount() >= RoundLimit) return True;
    }
    
    return False;
}

// ---------------------------------- //
/** Check if we should go to the next match
*
*	@return		True if it is the case, false otherwise
*/
Boolean MatchIsOver() {
    if (PointsLimitReached() == 0) return False; //< There is a tie and it is not allowed
    if (PointsLimitReached() == 1) return True; //< There is a points limit and it is reached
    if (S_MapsPerMatch > 0 && MB_GetMapCount() >= S_MapsPerMatch) return True; //< There is a maps limit and it is reached
    if (S_MapsPerMatch <= 0) return True;
    
    return False;
}

Void InitKEKUiLayer(){
    declare CUILayer Layer = UIManager.UILayerCreate();
    Layer.ManialinkPage = """
<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<manialink version="3">
<frame id="Frame_Stunts" hidden="1">
    <frame id="Frame_StuntInfo">
        <label id="Label_StuntsName" pos="0 65" z-index="0" size="100 10" text="" textfont="Gotham/Gotham-Bold" halign="center" valign="center" textsize="7" textemboss="1" hidden="1"/>
        <label id="Label_StuntReward" pos="0 56" z-index="0" size="100 10" text="" textfont="Gotham/Gotham-Bold" halign="center" valign="center" textsize="5" textemboss="1" hidden="1"/>
    </frame>
    <frame id="Frame_StuntPoints" pos="146 1.5">
        <label pos="3 0.5" z-index="0" size="17 10" text="9999" halign="right" valign="center" textfont="Gotham/Gotham-Bold" textemboss="1" textsize="4" id="Label_StuntPoints"/>
        <quad pos="9 0.5" z-index="0" size="10 10" bgcolor="FFFA" halign="center" valign="center" style="BgRaceScore2" substyle="Points"/>
        <quad pos="15 0" z-index="0" size="50 20" bgcolor="FFFA" style="Bgs1InRace" substyle="Glow" halign="right" valign="center" colorize="444"/>
        <quad pos="30 0" z-index="0" size="50 20" bgcolor="FFFA" style="Bgs1InRace" substyle="Glow" halign="right" valign="center" colorize="444"/>
        <quad pos="45 0" z-index="0" size="50 20" bgcolor="FFFA" style="Bgs1InRace" substyle="Glow" halign="right" valign="center" colorize="444"/>
        <quad pos="60 0" z-index="0" size="50 20" bgcolor="FFFA" style="Bgs1InRace" substyle="Glow" halign="right" valign="center" colorize="444"/>
    </frame>
</frame>
<frame id="Frame_EffectInfo" pos="0 80">
    <frame id="Frame_OldBonusInfoBG" hidden="1">
        <quad pos="25 -12.5" z-index="0" size="5 5" bgcolor="FFFA" halign="center" valign="center" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/RoundedOuter.png" rot="-90" colorize="555"/>
        <quad pos="40 -2.5" z-index="0" size="5 5" bgcolor="FFFA" halign="center" valign="center" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/RoundedOuter.png" rot="-90" colorize="555"/>
        <quad pos="25 -7.5" z-index="0" size="5 5" bgcolor="FFFA" halign="center" valign="center" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/ColorFill.png" colorize="555"/>
        <quad pos="40 5" z-index="0" size="5 10" bgcolor="FFFA" halign="center" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/ColorFill.png" colorize="555" valign="center"/>
        <quad pos="37.5 -2.5" z-index="0" size="10 5" bgcolor="FFFA" halign="right" valign="center" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/ColorFill.png" colorize="555"/>
        <quad pos="20 -7.5" z-index="0" size="5 5" bgcolor="FFFA" halign="center" valign="center" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/RoundedInner.png" rot="-90" colorize="555"/>
        <quad pos="25 -2.5" z-index="0" size="5 5" bgcolor="FFFA" halign="center" valign="center" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/RoundedOuter.png" rot="90" colorize="555"/>
        <quad pos="27.5 -5" z-index="0" size="5 10" bgcolor="FFFA" halign="left" valign="bottom" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/RoundedInner.png" rot="90" colorize="555"/>
        <quad pos="37.5555 1.1e-07" z-index="0" size="5 10" bgcolor="FFFA" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/RoundedInner.png" rot="-90" halign="left" valign="bottom" colorize="555"/>
        <quad pos="-25 -12.5" z-index="0" size="5 5" bgcolor="FFFA" halign="center" valign="center" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/RoundedOuter.png" colorize="555"/>
        <quad pos="-40 -2.5" z-index="0" size="5 5" bgcolor="FFFA" halign="center" valign="center" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/RoundedOuter.png" colorize="555"/>
        <quad pos="-25 -7.5" z-index="0" size="5 5" bgcolor="FFFA" halign="center" valign="center" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/ColorFill.png" colorize="555"/>
        <quad pos="-40 5" z-index="0" size="5 10" bgcolor="FFFA" halign="center" valign="center" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/ColorFill.png" colorize="555"/>
        <quad pos="-37.5 -2.5" z-index="0" size="10 5" bgcolor="FFFA" valign="center" halign="left" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/ColorFill.png" colorize="555"/>
        <quad pos="-20 -7.5" z-index="0" size="5 5" bgcolor="FFFA" halign="center" valign="center" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/RoundedInner.png" colorize="555"/>
        <quad pos="-25 -2.5" z-index="0" size="5 5" bgcolor="FFFA" halign="center" valign="center" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/RoundedOuter.png" rot="-180" colorize="555"/>
        <quad pos="-27.5 -5" z-index="0" size="10 5" bgcolor="FFFA" halign="left" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/RoundedInner.png" rot="-180" valign="bottom" colorize="555"/>
        <quad pos="-37.5 0" z-index="0" size="10 5" bgcolor="FFFA" halign="left" valign="bottom" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/RoundedInner.png" colorize="555"/>
        <quad pos="22.5 -12.5" z-index="0" size="45 5" bgcolor="FFFA" halign="right" valign="center" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/ColorFill.png" colorize="555"/>
    </frame>
    
    <label  z-index="0" size="60 10" text="Earthquake" halign="center" valign="center" pos="0 6" textsize="7" textemboss="1" textfont="Gotham/Gotham-Bold" id="Label_EffectName"/>
    <label  z-index="0" size="45 10" text="10" halign="center" valign="center" pos="0 -4" textsize="7" textemboss="1" textfont="Gotham/Gotham-Bold" id="Label_EffectTimer"/>
    
    <quad pos="-35 6" z-index="0" size="0.5 5" bgcolor="FFFA" halign="center" valign="center"/>
    <quad pos="-33 6" z-index="0" size="0.5 3" bgcolor="FFFA" halign="center" valign="center"/>
    <quad pos="-31 6" z-index="0" size="0.5 7" bgcolor="FFFA" halign="center" valign="center"/>
    <quad pos="35 6" z-index="0" size="0.5 5" bgcolor="FFFA" halign="center" valign="center"/>
    <quad pos="38 6" z-index="0" size="3 0.5" bgcolor="FFFA" halign="center" valign="center"/>
    <quad pos="-38 6" z-index="0" size="3 0.5" bgcolor="FFFA" halign="center" valign="center"/>
    <quad pos="33 6" z-index="0" size="0.5 3" bgcolor="FFFA" halign="center" valign="center"/>
    <quad pos="31 6" z-index="0" size="0.5 7" bgcolor="FFFA" halign="center" valign="center"/>
    <quad pos="0 0" z-index="0" size="80 0.5" bgcolor="FFFA" halign="center" valign="center"/>
    <quad pos="0 -10" z-index="0" size="42 0.5" bgcolor="FFFA" halign="center" valign="center" hidden="1"/>
    
    <quad pos="-20 -5" z-index="0" size="0.5 5" bgcolor="FFFA" halign="center" valign="center"/>
    <quad pos="-18 -5" z-index="0" size="0.5 3" bgcolor="FFFA" halign="center" valign="center"/>
    <quad pos="-16 -5" z-index="0" size="0.5 1" bgcolor="FFFA" halign="center" valign="center"/>
    <quad pos="-14.3 -5" z-index="0" size="5 0.5" bgcolor="FFFA" halign="left" valign="center"/>
    <quad pos="20 -5" z-index="0" size="0.5 5" bgcolor="FFFA" halign="center" valign="center"/>
    <quad pos="18 -5" z-index="0" size="0.5 3" bgcolor="FFFA" halign="center" valign="center"/>
    <quad pos="16 -5" z-index="0" size="0.5 1" bgcolor="FFFA" halign="center" valign="center"/>
    <quad pos="11.8 -5" z-index="0" size="5 0.5" bgcolor="FFFA" halign="center" valign="center"/>
    
    <quad pos="0 10" z-index="0" size="75 12" bgcolor="555A" halign="center" valign="top" hidden="1"/>
    <quad pos="0 -10" z-index="0" size="50 8" bgcolor="555A" halign="center" valign="bottom" hidden="1"/>
<quad pos="0 40" z-index="0" size="300 100" bgcolor="FFFA" style="Bgs1InRace" substyle="Glow" halign="center" valign="center" colorize="444"/>
<quad pos="0 20" z-index="0" size="300 100" bgcolor="FFFA" style="Bgs1InRace" substyle="Glow" halign="center" valign="center" colorize="444"/>
    <quad pos="0 0" z-index="0" size="300 100" bgcolor="FFFA" style="Bgs1InRace" substyle="Glow" halign="center" valign="center" colorize="444"/>
</frame>
<frame id="Frame_KEKLEffects" pos="-45 -110" scale="1.0">
    <label pos="0 9" z-index="0" size="50 10" text="Map Effects" halign="center" valign="center" textfont="Gotham/Gotham-Bold" textemboss="1" textsize="5"/>
    <label pos="0 3.5" z-index="0" size="47 13" text="Effect1, Effect2, Effect3, Effect4, Effect5" halign="center" textfont="Gotham/Gotham-Medium" textemboss="1" textsize="1.5" autonewline="1" id="Label_EffectList" valign="top"/>
    <quad pos="-25 -5" z-index="0" size="5 35" bgcolor="FFFA" halign="center" valign="center" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/ColorFill.png" opacity="1.0" colorize="435"/>
    <quad pos="25 -5" z-index="0" size="5 35" bgcolor="FFFA" halign="center" valign="center" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/ColorFill.png" opacity="1.0" colorize="435"/>
    <quad pos="0 15" z-index="0" size="45 5" bgcolor="FFFA" halign="center" valign="center" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/ColorFill.png" opacity="1.0" colorize="435"/>
    <quad pos="22.5 12.5" z-index="0" size="5 5" bgcolor="FFFA" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/RoundedOuter.png" opacity="1.0" rot="180" valign="top" halign="right" colorize="435"/>
    <quad pos="-22.5 12.5" z-index="0" size="5 5" bgcolor="FFFA" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/RoundedOuter.png" opacity="1.0" rot="90" valign="top" halign="right" colorize="435"/>
    <quad pos="20435 10" z-index="0" size="5 5" bgcolor="FFFA" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/RoundedInner.png" opacity="1.0" valign="center" halign="center" rot="180"/>
    <quad pos="-20 10" z-index="0" size="5 5" bgcolor="FFFA" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/RoundedInner.png" opacity="1" valign="center" halign="center" rot="90" colorize="435"/>
    <quad pos="0 9" z-index="0" size="50 10" bgcolor="FFFA" halign="center" valign="center" style="Bgs1" substyle="BgHealthBar"/>
    <quad pos="0 0" z-index="0" size="50 30" bgcolor="FFFA" halign="center" valign="center" image="https://raw.githubusercontent.com/Plambt/TM-SMScripts/main/Media/GradientBG.png" opacity="0.5" id="Quad_EffectBG" modulatecolor="C9F"/>
</frame>
<quad  z-index="0" size="320 180" bgcolor="FFFA" halign="center" valign="center" image="file://Media/Images/ManiaPlanet_HpJ56h7v53.jpg" hidden="1"/> <!-- I'm never removing this :) -->
<frame id="Frame_Vignette" pos="0 0" hidden="1">
    <label pos="0 -60" z-index="0" size="100 10" text="Penalty Time:" halign="center" valign="center" textfont="Gotham/Gotham-Medium" textemboss="1" textsize="5"/>
    <label pos="0 -67" z-index="0" size="100 10" text="10" halign="center" valign="center" textfont="Gotham/Gotham-Bold" textemboss="1" textsize="5" textcolor="F00" id="Label_PenaltyTimer"/>
    <quad pos="0 0" z-index="-10000" size="320 180" bgcolor="00000000" image="file://Media/Images/Effects/Vignette.dds" halign="center" valign="center"/>
    <quad pos="0 0" z-index="-10000" size="320 180" bgcolor="00000000" image="file://Media/Images/Effects/Vignette.dds" halign="center" valign="center"/>
    <quad pos="0 0" z-index="-10000" size="320 180" bgcolor="FF000011" halign="center" valign="center"/>
</frame>
<script><!--
    #Include "TextLib" as TL
    #Include "MathLib" as ML
    #Include "ColorLib" as CL
    
    #Struct NetEffectData{
        Text EffectName;
        Text EffectTime;
        Vec3 EffectTimeColor;
    }

    #Struct NetStuntData{
        Text StuntName;
        Integer StuntScore;
        Integer StuntTime;
    }
    
    declare CMlLabel MapSettings;
    declare Integer MapInfoTimeout;
    declare Text RecentMapUid;
    declare CMlFrame BonusFrame;
    declare CMlFrame VignetteFrame;
    declare CMlFrame StuntsFrame;
    
    Text GetNextRainbowColor(Text CurColor){
        declare Text[Text] Yummers = ["faa" => "fda", "fda" => "ffa", "ffa" => "bfa", "bfa" => "aff", "aff" => "daf", "daf" => "faa"];
        return Yummers[CurColor];
    }
    
    Text BonusEnumToText(CTmMlPlayer::ETmBonusModeEventType BonusType, Boolean IsExtra){
        declare Text NewEffectName = "";
        switch (BonusType){
            case CTmMlPlayer::ETmBonusModeEventType::Bumps: {
                NewEffectName = "$fdaEarthquake";
            }
            case CTmMlPlayer::ETmBonusModeEventType::LowGravity: {
                NewEffectName = "$aefLevitation";
            }
            case CTmMlPlayer::ETmBonusModeEventType::FreeWheeling: {
                NewEffectName = "$faaFreeWheeling";
            }
            case CTmMlPlayer::ETmBonusModeEventType::LockedDirections: {
                NewEffectName = "$dafNoSteering";
            }
            default: {
                NewEffectName = "$FFFNone";
            }
        }
        if (IsExtra){
            NewEffectName = NewEffectName ^ " $db3+";
        }
        return NewEffectName;
    }
    Void VignetteVisibility(Boolean Shown, CTmMlPlayer Player){
        if (Player != Null){
            declare CMlLabel PenaltyTimer = (Page.GetFirstChild("Label_PenaltyTimer") as CMlLabel);
            declare netread Integer[Text] NetPentalty for Teams[0];
            if (NetPentalty.existskey(Player.User.Login)){
                if (NetPentalty[Player.User.Login] != 0){
                    if (Shown){
                        PenaltyTimer.Value = ((NetPentalty[Player.User.Login] - GameTime) / 1000) + 1 ^ "";
                        VignetteFrame.Show();
                    }
                    else {
                        VignetteFrame.Hide();
                    }
                }
                else {
                    VignetteFrame.Hide();
                }
            }
            else {
                VignetteFrame.Hide();
            }
        }
        else {
            VignetteFrame.Hide();
        }
    }
    Void BonusEffectVisibility(Boolean Shown, CTmMlPlayer ViewedPlayer, CTmMlPlayer ClientPlayer){
        declare metadata Boolean RandEvents for Map;
        declare CMlLabel BonusName = (Page.GetFirstChild("Label_EffectName") as CMlLabel);
        declare CMlLabel BonusTimer = (Page.GetFirstChild("Label_EffectTimer") as CMlLabel);
        if (ViewedPlayer != Null){
            declare NetEffectData EffectData;
            if (ViewedPlayer.RaceState == CTmMlPlayer::ERaceState::Running){
                EffectData.EffectName = BonusEnumToText(ViewedPlayer.BonusModeEventType, ViewedPlayer.BonusModeEventIsGold);
                if (ViewedPlayer.BonusModeTimeTillEvent <= 6000 && ViewedPlayer.BonusModeTimeTillEvent != 0){
                    EffectData.EffectTimeColor = CL::HexToRgb("F22");
                    EffectData.EffectTime = (ViewedPlayer.BonusModeTimeTillEvent / 1000) + 1 ^ "";
                }
                else if (ViewedPlayer.BonusModeTimeTillEvent == 0){
                    EffectData.EffectTimeColor = CL::HexToRgb("F90");
                    EffectData.EffectTime = (ViewedPlayer.BonusModeTimeTillEndEvent / 1000) + 1 ^ "";
                    
                }
                else {
                    EffectData.EffectTimeColor = CL::HexToRgb("FFF");
                    EffectData.EffectTime = (ViewedPlayer.BonusModeTimeTillEvent / 1000) + 1 ^ "";
                }
            }
            else {
                declare Text CurYummer for Teams[0];
                declare Integer NextYumm for Teams[0];
                EffectData.EffectName = "$" ^ CurYummer ^ "Please Wait";
                EffectData.EffectTime = "$" ^ CurYummer ^ "...";
                if (Now >= NextYumm){
                    if (CurYummer == ""){
                        CurYummer = "faa";
                    }
                    CurYummer = GetNextRainbowColor(CurYummer);
                    NextYumm = Now + 100;
                }
            }
            BonusTimer.TextColor = EffectData.EffectTimeColor;
            BonusTimer.Value = EffectData.EffectTime;
            BonusName.Value = EffectData.EffectName;
            if (ClientPlayer != ViewedPlayer){
                BonusFrame.Hide();
            }
            else{
                if (RandEvents){
                    if (Shown){
                        BonusFrame.Show();
                    }
                    else {
                        BonusFrame.Hide();
                    }
                }
                else {
                    BonusFrame.Hide();
                }
            }
        }
        else {
            BonusFrame.Hide();
        }
    }
    
    Void ManageStunts(CTmMlPlayer Player){
        declare metadata Boolean IncStuntPoints for Map;
        declare CMlLabel StuntName = (Page.GetFirstChild("Label_StuntsName") as CMlLabel);
        declare CMlLabel StuntReward = (Page.GetFirstChild("Label_StuntReward") as CMlLabel);
        declare CMlLabel StuntPoints = (Page.GetFirstChild("Label_StuntPoints") as CMlLabel);
        if (Player != Null){
            declare netread Integer ScriptedStuntPoints for Player.Score;
            declare netread NetStuntData NetStuntEvent for Player.Score;
            StuntName.Value = NetStuntEvent.StuntName;
            if (NetStuntEvent.StuntScore > 0){
                StuntReward.Value = "+" ^ NetStuntEvent.StuntScore;
            }
            else {
                StuntReward.Value = "" ^ NetStuntEvent.StuntScore;
            }
            StuntPoints.Value = ScriptedStuntPoints ^ "";
            if (GameTime - NetStuntEvent.StuntTime >= 2000) {
                StuntName.Hide();
                StuntReward.Hide();
            }
            else{
                StuntName.Show();
                StuntReward.Show();
            }
            if (IncStuntPoints){
                StuntsFrame.Show();
            }
            else {
                StuntsFrame.Hide();
            }
        }
        else {
            StuntsFrame.Hide();
        }
        
    }
    
    Void UpdateEffectPage(){
        declare Text[] EffectNames;
        declare metadata Boolean RandEvents for Map;
        declare metadata Boolean LowGravity for Map;
        declare metadata Boolean RandCars for Map;
        declare metadata Boolean IncStuntPoints for Map;
        declare metadata Boolean UseCrashPenalty for Map;
        declare metadata Integer EffectVersion for Map;
        declare metadata Boolean SizeChanges for Map;
        declare metadata Integer RoundLimit for Map;
        declare metadata Boolean RandomFinishes for Map;
        if (LowGravity) {
            EffectNames.add("LowGravity");
        }
        switch (EffectVersion) {
            case 0: {
                if (RandEvents){
                    EffectNames.add("RandomEvents");
                    EffectNames.add("SizeChanges");
                }
            }
            default: {
                if (RandEvents) {
                    EffectNames.add("RandomEvents");
                }
                if (SizeChanges) {
                    EffectNames.add("SizeChanges");
                }
            }
        }
        
        if (RandCars) {
            EffectNames.add("RandomCars");
        }
        if (IncStuntPoints) {
            EffectNames.add("StuntsBonus");
        }
        if (UseCrashPenalty) {
            EffectNames.add("CrashPenalty");
        }
        if (!(RoundLimit <= 0) && !(RoundLimit > 3)) {
            EffectNames.add("RoundsLimit");
        }
        if (RandomFinishes){
            EffectNames.add("RandFinish");
        }
        if (EffectNames.count == 0) {
            MapSettings.Value = "None";
        }
        else {
            MapSettings.Value = TL::Join(", ", EffectNames);
        }
    }
    
    main() {
        VignetteFrame = (Page.GetFirstChild("Frame_Vignette") as CMlFrame);
        BonusFrame = (Page.GetFirstChild("Frame_EffectInfo") as CMlFrame);
        StuntsFrame = (Page.GetFirstChild("Frame_Stunts") as CMlFrame);
        declare CMlFrame EffectsFrame = (Page.GetFirstChild("Frame_KEKLEffects") as CMlFrame);
        declare Boolean InfoHasMovedIn = False;
        declare Text EventType;
        MapSettings = (Page.GetFirstChild("Label_EffectList") as CMlLabel);
        
        MapInfoTimeout = -1;
        while(True) {
            yield;
            if(Map != Null){
                if (Map.MapInfo.MapUid != RecentMapUid) {
                    UpdateEffectPage();
                    RecentMapUid = Map.MapInfo.MapUid;
                }
            }
            if (MapInfoTimeout >= Now) {
                if (!InfoHasMovedIn) {
                    AnimMgr.Add(EffectsFrame, "<frame pos=\"-45 -80\" />", Now, 250, CAnimManager::EAnimManagerEasing::ExpIn);
                    InfoHasMovedIn = True;
                }
            }
            else if (InfoHasMovedIn) {
                AnimMgr.Add(EffectsFrame, "<frame pos=\"-45 -110\" />", Now, 250, CAnimManager::EAnimManagerEasing::ExpOut);
                InfoHasMovedIn = False;
            }
            ManageStunts(GUIPlayer);
            if (GUIPlayer != Null){
                declare Integer PlayerStuntPoints for GUIPlayer.User;
                BonusEffectVisibility(True, GUIPlayer, InputPlayer);
                VignetteVisibility(True, GUIPlayer);
                if (GUIPlayer.RaceState == CTmMlPlayer::ERaceState::BeforeStart) {
                    PlayerStuntPoints = 0;
                    MapInfoTimeout = Now + 2000;
                }
                
                foreach (Event in RaceEvents) {
                    if (Event.Player == GUIPlayer) {
                        switch (Event.Type) {
                            case CTmRaceClientEvent::EType::Turbo : {
                                EventType = "Turbo";
                            }
                            case CTmRaceClientEvent::EType::Horn : {
                                EventType = "Horn";
                            }
                            case CTmRaceClientEvent::EType::Impact : {
                                EventType = "Impact";
                            }
                            case CTmRaceClientEvent::EType::WaterSplash : {
                                EventType = "WaterSplash";
                            }
                            case CTmRaceClientEvent::EType::GlassSmash : {
                                EventType = "GlassSmash";
                            }
                            case CTmRaceClientEvent::EType::PartDetached : {
                                EventType = "PartDetached";
                            }
                            default: {
                                EventType = "Unknown";
                            }
                        }
                        if (EventType != "Unknown") {
                            SendCustomEvent("RaceEvent", [EventType, Event.Player.Login]);
                        }
                    }
                }
            }
            else {
                VignetteVisibility(False, Null);
                BonusEffectVisibility(False, Null, Null);
            }
        }
    }
    --></script>
</manialink>
""";
    Layer.Type = CUILayer::EUILayerType::Normal;
    UIManager.UIAll.UILayers.add(Layer);
}
